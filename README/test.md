## 単体テスト (Unit Test)

単体テストは、アプリケーションを構成する最小単位のコンポーネント（関数、メソッド、クラスなど）が、個々に期待通りに動作するかを検証するテストです。

### 特徴

* **分離**: 対象ユニットを他から分離し、依存はテストダブル（Mock, Stub）で代替
* **高速**: 小規模なため短時間で完了する
* **早期発見**: 開バグを開発サイクルの早い段階で発見し、修正コストを低減できる
* **リファクタリング支援**: コード改善時の安心材料となる

### GIVEN-WEHN-THEN について
GIVEN, WHEN, THEN は、テストケースや仕様を明確に記述するための構造化パターンです。

**GIVEN (前提)**
テスト対象の初期状態や、テストを実行するための前提条件を記述します。
例：「ユーザーがログインしている状態で」

**WHEN (操作)**
実際に行う操作や、発生するイベントを記述します。
例：「"記事を投稿する" ボタンをクリックすると」

**THEN (結果)**
操作の結果として期待される状態や、検証すべき振る舞いを記述します。
例：「"投稿しました" というメッセージが表示され、記事が一覧に追加される」
このパターンに従うことで、テストの目的、手順、期待値が誰にとっても理解しやすくなります。


### FIRST原則

FIRST原則は、質の高いユニットテストを作成するための指針を示す、以下の5つのキーワードの頭文字を取ったものです。[参考](https://zenn.dev/t_kitamura/books/2ff9c13d5549d9/viewer/6f4961)

1. Fast (迅速であること) 
テストは迅速に実行できるべきです。理想的には数ミリ秒で完了することが望ましい。
データベース、ファイル、ネットワークなどの外部リソースに依存するテストは実行に時間がかかりがち。これらはユニットテストの迅速性を損なう要因となる。

2. Isolated (隔離されていること / 独立していること) 
良いユニットテストは、コードのごく一部（ユニット）に焦点を当てて検証します。テスト対象の範囲が広がるほど、テストの質は低下する傾向にあります。
各テストは他のテストケースから独立しており、実行順序や他のテストの結果に影響されるべきではありません。
データベースの特定の状態など、外部の状態に依存すると、テストが壊れやすくなったり、他の開発者の作業と競合したりする可能性があります。

3. Repeatable (繰り返し可能であること) 
テストは、実行するたびに同じ結果を安定して得られるべきです。
これを実現するためには、テストがコントロールできない外部環境要因（例: 現在時刻、乱数など）から完全に切り離されている必要があります。
外部要因が避けられない場合は、モックオブジェクトなどを使用して、テスト対象コードを不確定要素から隔離することが有効です。

4. Self-Validating (自己検証的であること) 
テストは、成功か失敗かをそれ自身で判断できなければなりません。
テストコード内でアサーション（表明）を用いて期待結果と実際の結果を比較検証し、自動的に合否を判定するようにします。
ログ出力を見て人間が手動で結果を検証する方法は、時間がかかり、見落としのリスクも高まります。

5. Timely (タイムリーであること / 適時であること) ⏱
ユニットテストは、テスト対象のコードを書くのと同時か、理想的にはそれより前に書かれるべきです（テスト駆動開発 - TDD）。
テスト作成を後回しにすると、コードが複雑化したり、仕様の記憶が曖昧になったりして、効果的なテストを書くのが難しくなります。
コードをリポジトリにチェックインした後では、テストを追加するモチベーションが低下しがちです。

### Swift での実装 - XCTest

標準的に **`XCTest`** フレームワークを利用します。

```swift
import XCTest
@testable import YourApp // テスト対象のモジュールをインポート

class CalculatorTests: XCTestCase {

    func testAdd() {
        // GIVEN
        let calculator = Calculator()

        // WHEN
        let result = calculator.add(2, 3)

        // THEN
        XCTAssertEqual(result, 5, "2 + 3 は 5 になるべきです")
    }

    func testSubtract() {
        // GIVEN
        let calculator = Calculator()

        // WHEN
        let result = calculator.subtract(5, 2)

        // THEN
        XCTAssertEqual(result, 3, "5 - 2 は 3 になるべきです")
    }
}
```

### Swift での実装 - swift-testing

```swift
// import XCTest
import Testing    // swift-testing のライブラリ
@testable import YourApp // テスト対象のモジュールをインポート

@Suite("Calculator Tests")    // 関連テストのグループ化
class CalculatorTests: XCTestCase {

    
    @Test("加算機能のテスト", .tags(.arithmetic))   // @Test マクロでテスト関数を定義, .arithmetic: 算術的な操作（計算処理）に関連するテストを分類するためのユーザー定義のタグ
    func testAdd() {
        // GIVEN
        let calculator = Calculator()

        // WHEN
        let result = calculator.add(2, 3)

        // THEN
        // XCTAssertEqual(result, 5, "2 + 3 は 5 になるべきです")
        #expect(result == 5, "2 + 3 は 5 になるべきです") // #expect でアサーション
    }

    @Test("減算機能のテスト", .tags(.arithmetic))
    func testSubtract() {
        // GIVEN
        let calculator = Calculator()

        // WHEN
        let result = calculator.subtract(5, 2)

        // THEN
        // XCTAssertEqual(result, 3, "5 - 2 は 3 になるべきです")
        #expect(result == 3, "5 - 2 は 3 になるべきです")
    }
}

// (オプション) テストで使用するタグを定義
extension Tag {
    @Tag static var arithmetic: Self // "arithmetic" タグ
}
```


#### Swift Testing のポイント
swift-testing (または Testing) は、Appleによって導入された新しいテストライブラリで、XCTest に代わる、よりモダンでSwiftらしいテスト体験を提供することを目指しています。主なポイントは以下の通りです。

1. **マクロベースの宣言 (@Test, @Suite)**
テスト関数は @Test マクロを付けて宣言します。XCTest のようにメソッド名の接頭辞 (test...) は不要です。
@Suite マクロを使用すると、関連するテストを構造体やクラス内にグループ化でき、テストの構成がより明確になります。

2. **表現力豊かなアサーション (#expect)**
XCTAssertEqual や XCTAssertTrue などの代わりに、ブール条件を取る #expect() マクロを使用します。
#expect(calculator.add(2, 3) == 5) のように、式を直接記述でき、より直感的です。
失敗時のカスタムメッセージも引数として追加できます。

3. **XCTestCase の継承不要**
XCTestCase クラスを継承する必要がなくなりました。これにより、テストコードの構造がより柔軟になり、Swiftの他の機能（例: プロトコル、ジェネリクスなど）をテスト構造に活用しやすくなります。

4. **タグ付けとフィルタリング (.tags())**
@Test や @Suite に .tags() を使用してタグを付与できます。これにより、特定のタグが付いたテストのみを実行するなど、テストのフィルタリングやグループ化が容易になります。
例: .tags(.ui, .slow, .featureX)

5. **パラメータ化テスト**
@Test 関数の引数にコレクションを渡すことで、同じテストロジックを異なる入力値で簡単に繰り返し実行できます。これにより、テストの記述量を減らし、網羅性を高めることができます。
```Swift

@Test("偶数性のテスト", arguments: [0, 2, 4, -2])
func testIsEven(number: Int) {
    #expect(number.isMultiple(of: 2))
}
```
6. **より詳細なテスト構成と制御**
テストの表示名、期待される失敗、スキップ条件などを @Test マクロの引数で細かく設定できます。

7. **Swift Concurrency のサポート**
async/await を使用した非同期コードのテストがより自然に記述できます。


## 結合テスト (Integration Test)

結合テストとは、個別に開発・テストされた複数のソフトウェアコンポーネント（モジュール、クラス、サービスなど）を組み合わせて、それらが正しく連携して動作するかを検証するテストフェーズです。単体テストが個々の部品の機能保証を目的とするのに対し、結合テストは部品間の「つなぎ目」や「相互作用」に焦点を当てます。

### 目的

- コンポーネント間のインターフェースが正しく機能することを確認する
- モジュール間で受け渡されるデータの整合性を検証する
- 連携時に発生する可能性のある欠陥やバグを早期に発見する（例：データ形式の不一致、呼び出しシーケンスの問題、予期せぬ副作用など）
- システム全体としての機能が、部分的な組み合わせの段階で期待通りに動作し始めているかを確認する
